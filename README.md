# Java_Laba_3

Выполнил Половников Тимофей

Внутри 4 "пакета" с файлами

1 - Main с вызовом всех задач и пользовательским интерфейсом

2 - Valid с проверкой входных данных

3 - City с городами и дорогами

4 - Fraction для действий с дробями

Задачи и их решения:

***
1 задание (Задачи 4)

Измените сущность Дробь из задачи 1.5.5. Реализуйте следующие требования:
Дробь не может быть изменена после создания
Необходимо корректно обрабатывать отрицательные значения. Учтите, что знаменатель
не может быть отрицательным.
Продемонстрируйте работоспособность решения на примерах.

Измените сущности из задачи 1.3.3. Гарантируйте, что между двумя городами может быть только
одна прямая дорога (другой путь может быть проложен только транзитом через другие города).
Города можно создавать с указанием заранее заданных путей, в любой момент времени можно
добавить новую дорогу в любой город и удалить имеющуюся дорогу.

4 задача решается дополнением класса "Fraction" с прошлой лабораторной работы.
Внутри класса 2 поля: numerator и denominator. Они имеют параметр final, что не дает им изменяться после инициализации. Также есть конструктор, в котором есть проверка на 0 в знаменателе,
работа с отрицательным знаменателем (Просто меняется знак числителя и знаменателя) и присвоение значений. Также есть конструктор
который работает со знаменателем = 1 и конструктор который работает с обыкновенными дробями (1 знак после запятой). Кроме этого
есть по геттеру для каждого поля и метод перевода обыкновенной дроби в десятичную. Далее следует выполнение всех математических операции с дробями
(Сложение, вычитание, умножение и деление) и выполнение с натуральным числом, а не с дробью. В методе с делением проверяется, чтоб не было деления на 0. Самый последний метод это toString который отвечает за вывод
результата строкой. Если знаменатель = 1, то выводится только числитель, иначе числитель / знаменатель.

В main задается 3 дроби и показывается их изменение при разных условиях задания: положительный числитель и знаменатель, отрицательный числитель и положительный знаменатель и положительный числитель и отрицательный знаменатель.
***

(Задача 10)

10 задача решается дополнением класса "City" из предыдущей лабораторной работы.
Внутри класса 2 поля: name, который хранит название города и ways, словарь дорог к другим городам с длинной.
Класс имеет 2 конструктора: с названием города и пустым списком дорог от него и название города со списком дорог и их длинами.
Также класс содержит по геттеру для каждого поля и сеттер для названия. Также есть метод добавления дорог от города к городу.
В методе есть проверка на пустое название города, неположительную длину дороги и дороги в себя же. Также дорога не должна быть создана ранее (Она прост не создается, если уже есть)
Следующий метод removeRoad удаляет дорогу между городами, но прежде делает проверку на пустое название введенного города и наличие удаляемой дороги. Удаление происходит с 2-х сторон,
то есть дорога удаляется из списка 1 и 2 города. Также есть стандартный для всех классов метод toString, который выводит результат в строковом представлении

В main создается 3 города, а также дороги из 1 во 2 с длинной 5 и из 1 в 3 с длиной в 7. После идет проверка, что нельзя добавить дорогу из 1 города в этот же город, затем проверка на дублирование дороги (нелья создать одну дорогу дважды). После
задаем город по заданным дорогам. В нашем случае это "Город4" с дорогами в 1 с длинной в 2 и в 3 с длинной в 8. Затем происходит удаление самой первой добавленной дороги: из Города1 в Город2 и с длинной 5 и полученный список выводится на экран.
***
2 Задание (Задача 5)

Данная задача предполагает разработку новой сущности на основе той, что была получена в
задаче 1.4.8 (Город). Сущность Город может быть доработана по своему усмотрению для более
удобного использования.
Основная идея задачи в разработке такой сущности, которая будет представлять собой маршрут
между двумя городами. Данный маршрут в любой момент времени можно получить как массив
для дальнейшего использования. Сущность Маршрут имеет следующие характеристики:
 Имеет Город начала и Город конца пути.
 Инициализация Маршрута может быть выполнена только если указана точка начала и
конца пути. Если указано nullзначение - то ошибка.
 Точку начала и конца можно изменить в любой момент времени, но они всегда должны
существовать.
 Может вернуть массив Городов, представляющий собой маршрут из начала в конец.
Массив содержит все Города (в порядке очереди) через которые надо пройти что бы
попасть из Города начала в Город конца, причем и начало и конец также содержатся в
этом массиве. Алгоритм формирования пути в данном случае не существенен, можно
выбрать вариант со случайным путем, путем проходящим через наименьшее число
городов, или самым дешевым путем. Если путь найти невозможно – возвращается пустой
массив.
 Маршрут может быть приведен к строке, которая будет возвращать название всех
городов маршрута в порядке очередности.
 Создание объекта и изменение точек начала и конца выполняется за константное время
O(1).
Воспользуйтесь картой городов из задачи 1.3.3 и выведите маршрут из Города F в Город D

Для решения задания создается новый класс Way. В нем есть 2 поля: start и finish, начальная и конечная точка пути.
В классе также есть конструктор, в котором проверяется нулевое название для города начала или конца. После есть геттер старта и геттер финиша,
а также сеттер старта и финиша. В сеттерах также проводится проверка на пустое название города. Также в классе присутствует ещё 2 метода:
поиск пути findWay и метод build, который восстанавливает полный маршрут из проходимых городов. В конце есть метод toString который
выводит результат в строковом представлении. 

Создается 7 городов и добавляются дороги как из 3 задания 2 лабораторной работы. Все города и их связи вывоодятся. После добавляется путь из F в D. Выводится методом toString, а затем и массивом городов.
***
Задание 3 (Задача 1)

Измените сущность Дробь, полученную в задаче 2.1.4. Гарантируйте, что невозможно создать
такой подвид дроби, который позволял бы создавать Дроби с изменяемым состоянием.

Для решения модернизируется класс Fraction из 1 задачи 1 задания. В поля numerator и denominator добавяется параметр final, который
не дает изменять переменную после её инициализации. Также сам класс получает параметр final, что означает, что класс нельзя наследовать. Также во всех
операциях нет изменений данных. Операции возвращают новые объекты. 
***
Задание 4 (Задача 2)

Измените сущность Дробь, полученную в задаче 2.3.1. Дробь должна быть подтипом класса
Number. Данный класс входит в стандартную редакцию языка Java.

Для решения задачи мы также модернизируем класс Fraction. Мы создаем наследование из класса Number и реализовываем все его абстрактные методы:
возвращение целого числа, целого числа больше значения int, дробного числа типа float и double методами intValue, longValue, floatValue и doubleValue соответственно.

В main наглядно показывается полиморфизм тем, что создается дробь и переприсваивается переменной типа Number. С этой переменной можно работать как с обычной дробью. После реализуются все стандартные методы Number
***
Задание 5 (Задача 1)

Разработайте метод, который принимает набор числовых значений и возвращает их сумму в вещественной форме. С использованием данного метода
выполните сложения: ...

Задача решается модернизацией класса Fraction. Мы создаем interface для операции сложения, который возвращает ответ в вещественной форме.
Также создается новый файл Calculate чтобы реализовать интерфейс (Нельзя объявить интерфейс внутри и его же использовать), который возвращает десятичное значение дроби из класса Fraction

В main создается массив из значений, которые складываются и выводятся в вещественном виде
***
Задание 6 (Задача 5)

Измените сущность Город, полученную в задаче 2.1.10. Переопределите метод сравнения
объектов по состоянию таким образом, чтобы два Города считались одинаковыми тогда, когда у
них одинаковый набор путей в другие города. Также, подвид Города из задачи 2.3.3 должен быть
сравним с городом из задачи 2.1.10.

Задача решается модернизацией класса City, а точнее дополнением методом sameWays. Внутри него есть проверка на пустое название города, затем
инициализируется счетчик, который считает совпадения городов. Затем вложенные циклы, где сначала проходим по дорогам текущего города, а во вложенном цикле
по дорогам другого города и смотрим совпадения. Если все дороги совпали, то города считаются одинаковыми.

В main создается 4 города, 1 и последнему добавляются одинаковые пути во 2 и 3 с одинаковым расстоянием. Далее демонстрируется, что города "Равны" при одинаковом наборе путей, что и требуется по условию
***
Задание 7 (Задача 1)

Навести порядок.
Данная задача предполагает реорганизацию ранее написанных классов. Расположите все ранее
написанные классы по пакетам таким образом, чтобы логически близкие классы оказались
сгруппированы друг с другом. Имена пакетов должны иметь как минимум трехсоставную форму,
вида: ru.surname.type. Вместо surname следует подставить свою фамилию, а вместо type
подставить название логического блока. Например, классы описывающие точку, линию, ломаную
линию, фигуру, квадрат, треугольник, круг и прямоугольник можно расположить в пакете
ru.surname.geometry.

1 задача решается созданием "Пакетов", в которые перемещаются файлы с одинаковой тематикой. Например в "Пакет" City отправляется 2 файла:
City и Way, вель они взаимосвязаны. Один создает города, а второй дороги между ними. По итогу создается 4 "Пакета":
Main - внутри файл main с основным меню пользователя и интерфейсом Calculate для 5 задания
Fraction - внутри файл Fraction для всех действий с дробями
City - внутри файл City для создания городов и прямыми путями между ними и файл Way с путями из одного города в другой в том числе транзитом через ещё один и созданием в любой момент времени
Valid - внутри файл Valid с проверкой вводимых данных
***
(Задача 2)
2 Главный метод.
Создайте пакет ru.surname.main (вместо surname необходимо подставить собственную
фамилию) в котором расположить класс с точкой входа в исполнение программы (public static void
main). Также следует проверить, что ни в одном другом пакете нет классов имеющих точку входа
в исполнение программы. В этом же пакете необходимо расположить класс (или интерфейс) с
методами из задач блока 2.5 и продемонстрировать их работоспособность.
***
(Задача 3)
3 Возведение в степень.
Создайте метод принимающий две строки, в которых будут записаны числа X и Y. Возвращает
метод результат возведения X в степень Y. Для преобразования строки в число следует
использовать метод Integer.parseInt, а для возведения в степень метод Math.pow. Вызовите
разработанный метод передав туда параметры командной строки полученные точкой входа в
программу. Реализуйте метод так, что бы для возведения в степень и преобразования строки
использовались короткие имена статических методов.

Для выполнения последней задачи из 7 задания создается отдельный класс Power, который добавляется в новый пакет Power. В нем обрабатывается 2 строки, переводится в число с помощью Integer.parseInt и первое число возводится в степень второго числа. с помощью pow. Данные вводятся
с клавиатуры и проходят посимвольную проверку на число (Число, непустое значение, неотрицательность)
***
Задание 8 (Задача 3)

Измените сущность Дробь из 2.6.1. Переопределите метод клонирования, унаследованный от
класса Object, таким образом, чтобы при его вызове возвращался новый объект Дроби, значения
полей которого будут копиями оригинальной Дроби.

Для решения задания модернизируется класс Fraction, а точнее добавляется метод clone, который позволяет клонировать дробь и изменять клон не изменяя оригинала. В main создается дробь 3/4 и клонируется. Затем клон меняется (увеличивается на 5/4), а оригинал нет и сравнивается. Наглядно видно, что они отличаются
